MODULE X11;  (* RC 12.10.92, JT 13.12.94 *)
(* Oberon interface to X Window System Version 11 *)

  IMPORT S := SYSTEM, Kernel, Console, Args, ulmTypes;
  
  CONST
    WinNameStr = "ETH-Oberon (TM)";
    CopyrightStr = "  -  Copyright (c) 1991-95, ETH Zurich.";
    IconNameStr = "oberon";

    BackgroundCol = 0;
    ForegroundCol = 15;
    WhiteCol = BackgroundCol;
    BlackCol = ForegroundCol;

    (* drawing modes *)
    replace* = 0; paint* = 1; invert* = 2;
    (* color classes *)
    monochrome* = 0; grayscale* = 1; color* = 2;

  TYPE
	Pixmap* = LONGINT;

    Pattern* = LONGINT (* = PatternPtr *);
    PatternPtr* = POINTER TO PatternDesc;
    PatternDesc* = RECORD
      x*, y*: INTEGER;
      w*, h*: INTEGER;
      pixmap*: Pixmap
    END ;

    MetricDesc* = RECORD
      dx*, x*, y*, filler: INTEGER;
      p*: PatternDesc
    END ;

    Font* = POINTER TO Bytes;
    Bytes* = RECORD
      metrics*: ARRAY 256 OF MetricDesc;
      xid*: LONGINT
    END ;

    (* X types *)
    Display* = LONGINT;
    Window* = LONGINT;
    Drawable* = LONGINT;
    GC* = LONGINT;
    Bool* = (*LONGINT*)INTEGER;
    Colormap* = LONGINT;
    Time* = LONGINT;
    Atom* = LONGINT;

    VisualID* = LONGINT;
    Visual* = RECORD
      extData*: INTEGER;
      visualid*: VisualID;
      class*: INTEGER;
      redMask*, greenMask*, blueMask*: LONGINT;
      bitsPerRgb*, mapEntries*: INTEGER;
    END ;
    VisualPtr* = POINTER TO Visual;
    VisualInfo* = RECORD
      visual*: (*VisualPtr*) LONGINT;
      visualID*: VisualID;
      screen*, depth*, class*: INTEGER;
      redmask*, greenmask*, bluemask*: INTEGER;
      colomapsize*, bitsperrgb*: INTEGER
    END ;
    Color* = RECORD
      pixel*: LONGINT;
      red*, green*, blue*: ulmTypes.Int16;
      flags*, pad*: CHAR
    END ; (* xColor from Xlib.h *)
    Point* = RECORD x*, y*: ulmTypes.Int16 END ; (* probably typedef struct _xPoint; or XPoint from Xlib.h; same size anyway; -- noch *)
    Rectangle* = RECORD x*, y*, w*, h*: ulmTypes.Int16 END ; (*probably typedef struct _xRectangle; -- noch *)
    Cursor* = LONGINT;
    KeySym* = LONGINT;
    KeyCode* = LONGINT;
    Event* = RECORD (* this seems to be XCrossingEvent from Xlibint.h; -- noch *)
      type*: INTEGER;
	  serial*: LONGINT;
      sendEvent*: Bool;
      display*: Display;
      window*, root*, subwindow*: Window;
      time*: LONGINT;
	  x*, y*, xRoot*, yRoot*, state*, button*: INTEGER;
      sameScreen*, focus*: Bool;
      state2*: INTEGER;
      (*pad*: ARRAY 32 OF LONGINT*) (* cannot understand why this pad is needed, it does not correspond to any event type from xlibint.h *)
    END ;
    SelectionEvent* = RECORD
      type*: INTEGER;
	  serial*: LONGINT;
      sendEvent*: Bool;
      display*: Display;
      requestor*: Window;
      selection*, target*, property*: Atom;
      time*: Time
    END ;
    SelectionRequestEvent* = RECORD
      type*: INTEGER;
	  serial*: LONGINT;
      sendEvent*: Bool;
      display*: Display;
      owner*, requestor*: Window;
      selection*, target*, property*: Atom;
      time*: Time
    END ;
    Image* = LONGINT;
    ImagePtr* = POINTER TO ImageDesc;
    ImageDesc* = RECORD (* typedef struct _XImage *)
      width*, height*: INTEGER;
      xoffset*: INTEGER;
	  format*: INTEGER;
	  data*: LONGINT; (* char *data *)
      byteOrder*, bitmapUnit*, bitmapBitOrder*: INTEGER;
      bitmapPad*, depth*, bytesPerLine*, bitsPerPixel*: INTEGER;
      redmask*, greenmask*, bluemask*: LONGINT;
      obdata*: LONGINT;
	  createImage*, destroyImage*, getPixel*, putPixel*, subImage*, addPixel*: LONGINT
    END ;
    ErrorEvent* = RECORD
      type*: INTEGER;
      display*: Display;
      resourceid*, serial*: LONGINT;
      errorCode*, requestCode*, minorCode*: CHAR
    END ;
    ErrorEventPtr* = POINTER TO ErrorEvent;
    ErrorHandler* = PROCEDURE(display: Display; err: ErrorEventPtr): LONGINT;
    IOErrorHandler = PROCEDURE(display: Display): LONGINT;

    Modlist* = ARRAY 8, 32 OF CHAR;

  CONST (* X constants: <X11/X.h> *)
    False* = 0; True* = 1; None* = 0;
  (* line styles: *)
    LineSolid* = 0;
    LineOnOffDash* = 1;
    LineDoubleDash* = 2;
  (* cap styles: *)
    CapNotLast* = 0;
    CapButt* = 1;
    CapRound* = 2;
    CapProjecting* = 3;
  (* join styles: *)
    JoinMiter* = 0;
    JoinRound* = 1;
    JoinBevel* = 2;
  (* fill styles: *)
    FillSolid* = 0;
    FillTiled* = 1;
    FillStippled* = 2;
    FillOpaqueStippled* = 3;
  (* functions: *)
    GXand* = 1;
    GXcopy* = 3;
    GXxor* = 6;
    GXor* = 7;
    GXequiv* = 9;
  (* color flags: *)
    DoRed* = 1;
    DoGreen* = 2;
    DoBlue* = 4;
    DoAll* = DoRed + DoGreen + DoBlue;
  (* for CreateColormap : *)
    AllocNone* = 0;
    AllocAll* = 1;
  (* QueryBestSize Class: *)
    CursorShape* = 0;
    TileShape* = 1;
    StippleShape* = 2;
  (* visual classes: *)
    StaticGray* = 0;
    GrayScale* = 1;
    StaticColor* = 2;
    PseudoColor* = 3;
    TrueColor* = 4;
    DirectColor* = 5;
  (* arc modes: *)
    ArcChord* = 0;
    ArcPieSlice* = 1;
  (* polygone shape: *)
    Complex* = 0;
    Nonconvex* = 1;
    Convex* = 2;
  (* clip odering and origin: *)
    CoordModeOrigin* = 0;
    CoordModePrevious* = 1;
    Unsorted* = 0;
    YSorted* = 1;
    YXSorted* = 2;
    YXBanded* = 3;
  (* property modes: *)
    PropModeReplace* = 0;
  (* events types: *)
    KeyPress* = 2;
    ButtonPress* = 4;
    ButtonRelease* = 5;
    MotionNotify* = 6;
    FocusIn* = 9;
    FocusOut* = 10;
    Expose* = 12;
    GraphicsExpose* = 13;
    NoExpose* = 14;
    UnmapNotify* = 18;
    MapNotify* = 19;
    PropertyNotify* = 28;
    SelectionClear* = 29;
    SelectionRequest* = 30;
    SelectionNotify* = 31;
    ClientMessage* = 33;
    MappingNotify* = 34;
  (* event masks: *)
    KeyPressMask* = 1H;
    ButtonPressMask* = 4H;
    ButtonReleaseMask* = 8H;
    PointerMotionMask* = 40H;
    PointerMotionHintMask* = 80H;
    ButtonMotionMask* = 2000H;
    ExposureMask* = 8000H;
    StructureNotifyMask* = 20000H;
    FocusChangeMask* = 200000H;
    PropertyChangeMask* = 400000H;
    OwnerGrabButtonMask* = 1000000H;
  (* event modes:  <X11/Xlib.h> *)
    QueuedAlready* = 0;
    QueuedAfterReading* = 1;
    QueuedAfterFlush* = 2;
  (* focus revert modes: <X11/X.h> *)
    RevertToParent* = 2;
  (* buttons: *)
    Button1* = 1;
    Button2* = 2;
    Button3* = 3;
    Button1Mask* = 100H;
    Button2Mask* = 200H;
    Button3Mask* = 400H;
  (* image format: *)
    XYBitmap* = 0;
    XYPixmap* = 1;
    ZPixmap* = 2;
  (* special keys: <X11/keysymdef.h> *)
  (* cursor shapes: <X11/cursorfont.h> *)
    XCleftptr* = 132;
  (* atoms: <X11/Xatom.h> *)
    XAPRIMARY* = 1;
    XASTRING* = 31;

  (* line cache *)
    LcLen* = 256;

  VAR
    WinName*, IconName*, Copyright*, WinNameCopyright*: ARRAY 128 OF CHAR;
    display*: Display;
    primary*, secondary*, root*: Window;
    basePixel*, foreground*, background*: LONGINT;
    backgroundCol*, foregroundCol*: INTEGER;
    screen*, screenw*, screenh*, screenhmm*: INTEGER;
    cells*, planes*: LONGINT;
    visualptr*, defvisualptr*: LONGINT;
    cmap*, defcmap*: Colormap;
    Width*, Height*, Bottom*, UBottom*, ColLeft*, depth*: INTEGER;
    pixelValues*: ARRAY 256 OF LONGINT;
    function*: ARRAY 3 OF INTEGER;
    planesMask*: LONGINT;
    colorClass*: SHORTINT; (* monochrome, grayscale or color *)
    nofcol*: LONGINT;
    arrow*, noCursor*: Cursor;
    ErrorText*: ARRAY 80 OF CHAR;
    ErrorFlag*: BOOLEAN;
    lastEventTime*: Time;

  (* character cache *)
    ccp*: Pattern;
    ccf*: Font;
    ccch*: CHAR;
    ccdx*, ccx*, ccy*: INTEGER;

    lcache*: ARRAY LcLen OF CHAR;
    lcf*: Font;
    lcx0*, lcy0*, lcx*, lccol*, lcmode*, lclen*: INTEGER;

  (* cut and paste *)
    SendSelection*: PROCEDURE(VAR event: SelectionRequestEvent);
    ReceiveSelection*: PROCEDURE(VAR event: SelectionEvent);
    ClearSelection*: PROCEDURE;

    arrowSource, arrowMask, noCursorSource, noCursorMask: Pattern;
    RGB: ARRAY 257 OF RECORD r, g, b: INTEGER END;

    Gc: GC;  (* general purpose GC *)
    lastcol, lastmode: INTEGER;
    lastfont: Font;

  (* Xlib.h functions *)

  PROCEDURE -OpenDisplay*(name: ARRAY OF CHAR): LONGINT
      "(long)XOpenDisplay(name)";

  PROCEDURE -DefaultScreen*(display: Display): INTEGER
      "(long)XDefaultScreen(display)";

  PROCEDURE -DisplayWidth*(display: Display; screen: INTEGER): INTEGER
      "(long)XDisplayWidth(display, screen)";

  PROCEDURE -DisplayHeight*(display: Display; screen: INTEGER): INTEGER
      "(long)XDisplayHeight(display, screen)";

  PROCEDURE -DisplayHeightMM*(display: Display; screen: INTEGER): INTEGER
      "(long)XDisplayHeightMM(display, screen)";

  PROCEDURE -DefaultDepth*(display: Display; screen: INTEGER): INTEGER
      "(long)XDefaultDepth(display, screen)";

  PROCEDURE -DisplayCells*(display: Display; screen: INTEGER): INTEGER
      "(long)XDisplayCells(display, screen)";

  PROCEDURE -DisplayPlanes*(display: Display; screen: INTEGER): INTEGER
      "(long)XDisplayPlanes(display, screen)";

  PROCEDURE -BlackPixel*(display: Display; screen: INTEGER): LONGINT 
      "(long)XBlackPixel(display, screen)";

  PROCEDURE -WhitePixel*(display: Display; screen: INTEGER): LONGINT
      "(long)XWhitePixel(display, screen)";

  PROCEDURE -DefaultVisual*(display: Display; screen: INTEGER): LONGINT
      "(long)XDefaultVisual(display, screen)";

  PROCEDURE -DefaultColormap*(display: Display; screen: INTEGER): Colormap
      "(long)XDefaultColormap(display, screen)";

  PROCEDURE -DefaultRootWindow*(display: Display): Window
      "(long)XDefaultRootWindow(display)";

  PROCEDURE -CreateSimpleWindow*(display: Display; parent: Window;
                              x, y, width, height, borderWidth: INTEGER; border, background: LONGINT): Window
      "(long)XCreateSimpleWindow(display, parent, x, y, width, height, borderWidth, border, background)";

  PROCEDURE -TranslateCoordinates*(display: Display; sw, dw: Window; srcx, srcy: INTEGER;
                              VAR dstx, dsty: INTEGER; VAR child: Window)
      "XTranslateCoordinates(display, sw, dw, srcx, srcy, dstx, dsty, child)";

  PROCEDURE -MoveResizeWindow*(display: Display; window: Window; x, y, width, height: INTEGER)
      "XMoveResizeWindow(display, window, x, y, width, height)";

  PROCEDURE -StoreName*(display: Display; window: Window; name: LONGINT)(*: INTEGER*)
      "XStoreName(display, window, name)";

  PROCEDURE -SetIconName*(display: Display; window: Window; name: LONGINT)(*: INTEGER*)
      "XSetIconName(display, window, name)";

  PROCEDURE -SetCommand*(display: Display; window: Window; argv: LONGINT; argc: INTEGER)(*: INTEGER*)
      "XSetCommand(display, window, argv, argc)";

  PROCEDURE -Geometry*(display: Display; screen: INTEGER; user, default: ARRAY OF CHAR;
                      bwidth, fw, fh, xpad, ypad: INTEGER; VAR x, y, w, h: INTEGER): INTEGER
      "(long)XGeometry(display, screen, user, default, bwidth, fw, fh, xpad, ypad, x, y, w, h)";

  PROCEDURE -MapRaised*(display: Display; window: Window)(*: INTEGER*)
      "XMapRaised(display, window)";

  PROCEDURE -LowerWindow*(display: Display; window: Window)(*: INTEGER*)
      "XLowerWindow(display, window)";

  PROCEDURE -ClearWindow*(display: Display; window: Window)(*: INTEGER*)
      "XClearWindow(display, window)";

  PROCEDURE -Sync*(display: Display; discard: INTEGER)(*: INTEGER*)
      "XSync(display, discard)";

  PROCEDURE -Flush*(display: Display)
      "XFlush(display)";

  PROCEDURE -StoreColor*(display: Display; cmap: Colormap; color: LONGINT)
      "XStoreColor(display, cmap, color)";

  PROCEDURE -CreateBitmapFromData*(display: Display; drawable: Drawable;
                              data: LONGINT; width, height: INTEGER): Pixmap
      "(long)XCreateBitmapFromData(display, drawable, data, width, height)";

  PROCEDURE -CopyArea*(display: Display; src, dest: Drawable; gc: GC; srcX, srcY, width, height, destX, destY: INTEGER)
      "XCopyArea(display, src, dest, gc, srcX, srcY, width, height, destX, destY)";

  PROCEDURE -CopyPlane*(display: Display; src, dest: Drawable; gc: GC;
                    srcX, srcY, width, height, destX, destY: INTEGER; plane: LONGINT)
      "XCopyPlane(display, src, dest, gc, srcX, srcY, width, height, destX, destY, plane)";

  PROCEDURE -SetStipple*(display: Display; gc: GC; stipple: Pixmap)
      "XSetStipple(display, gc, stipple)";

  PROCEDURE -SetTSOrigin*(display: Display; gc: GC; tsxorigin, tsyorigin: INTEGER)
      "XSetTSOrigin(display, gc, tsxorigin, tsyorigin)";

  PROCEDURE -DrawPoint*(display: Display; window: Drawable; gc: GC; x, y: INTEGER)
      "XDrawPoint(display, window, gc, x, y)";

  PROCEDURE -FillRectangle*(display: Display; window: Drawable; gc: GC; x, y, width, height: INTEGER)
      "XFillRectangle(display, window, gc, x, y, width, height)";

  PROCEDURE -DrawString*(display: Display; window: Drawable; gc: GC; x, y: INTEGER; width: LONGINT; height: INTEGER)
      "XDrawString(display, window, gc, x, y, width, height)";

  PROCEDURE -CreateGC*(display: Display; drawable: Drawable; valueMask, values: LONGINT): GC
      "(long)XCreateGC(display, drawable, valueMask, values)";

  PROCEDURE -SetForeground*(display: Display; gc: GC; arg: LONGINT)
      "XSetForeground(display, gc, arg)";

  PROCEDURE -SetBackground*(display: Display; gc: GC; arg: LONGINT)
      "XSetBackground(display, gc, arg)";

  PROCEDURE -SetFunction*(display: Display; gc: GC; arg: INTEGER)
      "XSetFunction(display, gc, arg)";

  PROCEDURE -SetFont*(display: Display; gc: GC; arg: INTEGER)
      "XSetFont(display, gc, arg)";

  PROCEDURE -SetFillStyle*(display: Display; gc: GC; arg: INTEGER)
      "XSetFillStyle(display, gc, arg)";

  PROCEDURE -SetPlaneMask*(display: Display; gc: GC; mask: LONGINT)
      "XSetPlaneMask(display, gc, mask)";

  PROCEDURE -SetGraphicsExposures*(display: Display; gc: GC; graphicsExposures: Bool)
      "XSetGraphicsExposures(display,gc, graphicsExposures )";

  PROCEDURE -SetLineAttributes*(display: Display; gc: GC; lineWidth, lineStyle, capStyle, joinStyle: INTEGER)
      "XSetLineAttributes(display, gc, lineWidth, lineStyle, capStyle, joinStyle)";

  PROCEDURE -AllocColorCells*(display: Display; cmap: Colormap; contig: Bool;
                        planeMasks: LONGINT; nplanes: INTEGER; pixels: LONGINT; ncolors: INTEGER): INTEGER
      "(long)XAllocColorCells(display, cmap, contig, planeMasks, nplanes, pixels, ncolors)";

  PROCEDURE -SetWindowBackground*(display: Display; window: Window; pixel: LONGINT)
      "XSetWindowBackground(display, window, pixel)";

  PROCEDURE -CreateFontCursor*(display: Display; shape: INTEGER): Cursor
      "(long)XCreateFontCursor(display, shape)";

  PROCEDURE -CreatePixmapCursor*(display: Display; csource, cmask: Pixmap;
                            cfore, cback: LONGINT; xhot, yhot: INTEGER): Cursor
      "(long)XCreatePixmapCursor(display, csource, cmask, cfore, cback, xhot, yhot)";

  PROCEDURE -RecolorCursor*(display: Display; curs: Cursor; cfore, cback: LONGINT)
      "XRecolorCursor(display, curs, cfore, cback)";

  PROCEDURE -DefineCursor*(display: Display; window: Window; curs: Cursor)
      "XDefineCursor(display, window, curs)";

  PROCEDURE -DrawLine*(display: Display; window: Window; gc: GC; x1, y1, x2, y2: INTEGER)
      "XDrawLine(display, window, gc, x1, y1, x2, y2)";

  PROCEDURE -SetArcMode*(display: Display; gc: GC; arcmode: INTEGER)
      "XSetArcMode(display, gc, arcmode)";

  PROCEDURE -DrawArc*(display: Display; window: Window; gc: GC; x, y, width, height, angle1, angle2: INTEGER)
      "XDrawArc(display, window, gc, x, y, width, height, angle1, angle2)";

  PROCEDURE -FillArc*(display: Display; window: Window; gc: GC; x, y, width, height, angle1, angle2: INTEGER)
      "XFillArc(display, window, gc, x, y, width, height, angle1, angle2)";

  PROCEDURE -FillPolygon*(display: Display; window: Window; gc: GC; points: LONGINT; npoints, shape, mode: INTEGER)
      "XFillPolygon(display, window, gc, points, npoints, shape, mode)";

  PROCEDURE -SetClipMask*(display: Display; gc: GC; clipMask: Pixmap)
      "XSetClipMask(display, gc, clipMask)";

  PROCEDURE -SetClipRectangles*(display: Display; gc: GC; clipxorigin, clipyorigin: INTEGER; rectangles: LONGINT; n, ordering: INTEGER)
      "XSetClipRectangles(display, gc, clipxorigin, clipyorigin, rectangles, n, ordering)";

  PROCEDURE -ListFonts*(display: Display; pattern: LONGINT; maxnames: INTEGER; VAR count: INTEGER): LONGINT
      "(long)XListFonts(display, pattern, maxnames, count)";

  PROCEDURE -FreeFontNames*(list: LONGINT)
      "XFreeFontNames(list)";

  PROCEDURE -LoadFont*(display: Display; name: LONGINT): LONGINT
      "(long)XLoadFont(display, name)";

  PROCEDURE -SelectInput*(display: Display; window: Window; eventMask: LONGINT)
      "XSelectInput(display, window, eventMask)";

  PROCEDURE -NextEvent*(display: Display; event: LONGINT)
      "XNextEvent(display, event)";

  PROCEDURE -EventsQueued*(display: Display; mode: INTEGER): INTEGER
      "(long)XEventsQueued(display, mode)";

  PROCEDURE -SetInputFocus*(display: Display; focus: Window; revertTo: INTEGER; time: LONGINT)
      "XSetInputFocus(display, focus, revertTo, time)";

  (* Xutil.h functions; -- noch *)
  PROCEDURE -LookupString*(event, buffer: LONGINT; bufsize: INTEGER;
                        VAR keysym: KeySym; compstatus: LONGINT): LONGINT
      "(long)XLookupString(event, buffer, bufsize, keysym, compstatus)";

  PROCEDURE -QueryPointer*(display: Display; window: Window; VAR rw, cw: Window;
                        VAR xr, yr, xw, yw, keysButtons: INTEGER)
      "XQueryPointer(display, window, rw, cw, xr, yr, xw, yw, keysButtons)";

  PROCEDURE -RefreshKeyboardMapping*(event: LONGINT)
      "XRefreshKeyboardMapping(event)";

  PROCEDURE -Bell*(display: Display; percent: INTEGER)
      "XBell(display, percent)";

  PROCEDURE -RebindKeysym*(display: Display; reboundsym: KeySym; modlist: LONGINT; modlength: INTEGER;
                        newstring: LONGINT; newlength: INTEGER)
      "XRebindKeysym(display, reboundsym, modlist, modlength, newstring, newlength)";

  PROCEDURE -StringToKeysym*(string: LONGINT): KeySym
      "(long)XStringToKeysym(string)";

  PROCEDURE -CopyColormapAndFree*(display: Display; cmap: Colormap): Colormap
      "(long)XCopyColormapAndFree(display, cmap)";

  PROCEDURE -CreateColormap*(display: Display; window: Window; vis: LONGINT; alloc: INTEGER): Colormap
      "(long)XCreateColormap(display, window, vis, alloc)";

  PROCEDURE -MatchVisualInfo*(display: Display; screen, depth, class: INTEGER; vinforet: LONGINT): INTEGER
      "(long)XMatchVisualInfo(display, screen, depth, class, vinforet)";
   (* Xlib.h again *)
  PROCEDURE -SetWindowColormap*(display: Display; window: Window; cmap: Colormap)
      "XSetWindowColormap(display, window, cmap)";

  PROCEDURE -QueryBestSize*(display: Display; class: INTEGER; screen: Drawable;
                        width, height: INTEGER; VAR w, h: INTEGER)
      "XQueryBestSize(display, class, screen, width, height, w, h)";

  PROCEDURE -CreatePixmap*(display: Display; drawable: Drawable; width, height, depth: INTEGER): Pixmap
      "(long)XCreatePixmap(display,drawable, width, height, depth)";

  PROCEDURE -FreePixmap*(display: Display; pixmap: Pixmap)
      "XFreePixmap(display, pixmap)";

  PROCEDURE -CreateImage*(display: Display; visual: LONGINT; depth, format, offset: INTEGER; data: LONGINT; 
                        width, height, bitmapPad, bytesPerLine: INTEGER): Image
      "(long)XCreateImage(display, visual, depth, format, offset, data, width, height, bitmapPad, bytesPerLine)";
   (* Xutil.h again *)
  PROCEDURE -DestroyImage*(image: Image)
      "XDestroyImage(image)";

  PROCEDURE -SubImage*(image: Image; x, y, width, height: INTEGER): Image
      "(long)XSubImage(image, x, y, width, height)";
   (* Xlib.h again *)
  PROCEDURE -GetImage*(display: Display; drawable: Drawable; x, y, 
                    width, height: INTEGER; planeMask: LONGINT; format: INTEGER): Image
      "(long)XGetImage(display, drawable, x, y, width, height, planeMask, format)";

  PROCEDURE -GetSubImage*(display: Display; drawable: Drawable; x, y, width, height: INTEGER; planeMask: LONGINT; format: INTEGER;
                        dstImage: Image; dstX, dstY: INTEGER): Image
      "(long)XGetSubImage(display, drawable, x, y, width, height, planeMask, format, dstImage, dstX, dstY)";

  PROCEDURE -PutImage*(display: Display; drawable: Drawable; gc: GC; image: Image; 
                      srcX, srcY, dstX, dstY, width, height: INTEGER)
      "XPutImage(display, drawable, gc, image, srcX, srcY, dstX, dstY, width, height)";
   (* Xutil.h again *)
  PROCEDURE -PutPixel*(image: Image; x, y: INTEGER; pixel: LONGINT): INTEGER
      "(long)XPutPixel(image, x, y, pixel)";

  PROCEDURE -GetPixel*(image: Image; x, y: INTEGER): LONGINT
      "(long)XGetPixel(image, x, y)";

  PROCEDURE -AddPixel*(image: Image; value: LONGINT)
      "XAddPixel(image, value)";
   (* Xlib.h again *)
  PROCEDURE -Free*(data: LONGINT)
      "XFree(data)";

  PROCEDURE -SetErrorHandler*(handler: ErrorHandler)
      "XSetErrorHandler(handler)";

  PROCEDURE -GetErrorText*(display: Display; code: INTEGER; buffer: LONGINT; length: INTEGER)
      "XGetErrorText(display, code, buffer, length)";

  PROCEDURE -StoreBytes*(display: Display; bytes: LONGINT; nbytes: INTEGER)
      "XStoreBytes(display, bytes, nbytes)";

  PROCEDURE -FetchBytes*(display: Display; VAR nbytes: INTEGER): LONGINT
      "(long)XFetchBytes(display, nbytes)";

  PROCEDURE -SetSelectionOwner*(display: Display; selection: Atom; owner: Window; time: Time)
      "XSetSelectionOwner(display, selection, owner, time)";

  PROCEDURE -GetSelectionOwner*(display: Display; selection: Atom): Window
      "(long)XGetSelectionOwner(display, selection)";

  PROCEDURE -InternAtom*(display: Display; name: LONGINT; onlyifexists: Bool): Atom
      "(long)XInternAtom(display, name, onlyifexists)";

  PROCEDURE -SendEvent*(display: Display; window: Window; propagate: Bool; eventmask, event: LONGINT)
      "XSendEvent(display, window, propagate, eventmask, event)";

  PROCEDURE -ConvertSelection*(display: Display; selection, target, property: Atom; 
                          requestor: Window; timestamp: Time)
      "XConvertSelection(display, selection, target, property, requestor, timestamp)";

  PROCEDURE -ChangeProperty*(display: Display; window: Window; property, type: Atom; 
                          format, mode: INTEGER; data: LONGINT; nelements: INTEGER)
      "XChangeProperty(display, window, property, type, format, mode, data, nelements)";

  PROCEDURE -GetWindowProperty*(display: Display; window: Window; property: Atom; offset, length: LONGINT;
                  delete: Bool; reqtype: Atom; VAR type: Atom; VAR format: INTEGER; VAR nitems, bytesafter, prop: LONGINT)
      "XGetWindowProperty(display, window, property, offset, length, delete, reqtype, type, format, nitems, bytesafter, prop)";

  PROCEDURE -DeleteProperty*(display: Display; window: Window; property: Atom)
      "XDeleteProperty(display, window, property)";

  PROCEDURE -WarpPointer*(display: Display; srcwin, dstwin: Window; srcx, srcy, srcw, srch, dstx, dsty: INTEGER)
      "XWarpPointer(display, srcwin, dstwin, srcx, srcy, srcw, srch, dstx, dsty)";

  PROCEDURE -InstallColormap*(display: Display; cmap: Colormap)
      "XInstallColormap(display, cmap)";

  PROCEDURE -GetGeometry*(display: Display; drawable: Drawable;
                        VAR root: Window; x, y, width, height, orderWidth, Depth: INTEGER)
      "XGetGeometry(display, drawable, root, x, y, width, height, orderWidth, Depth)";

  PROCEDURE -ResizeWindow*(display: Display; window: Window; x, y: INTEGER)
      "XResizeWindow(display, window, x, y)";

  PROCEDURE -SetIOErrorHandler*(handler: IOErrorHandler)
      "XSetIOErrorHandler(handler)";

  PROCEDURE NewPattern*(VAR image: ARRAY OF SET; class: LONGINT; width, height: INTEGER): Pattern;
    VAR pixmap: Pixmap; pat: PatternPtr; 
	w, h: INTEGER; 
	i, j, b, dest, srcw, destb, srci, desti: LONGINT;
    data: ARRAY 256*32 OF CHAR; (* 256*256 bits *)
  BEGIN i := 0;
    Console.String("***DBG*** X11.Mod *** PROCEDURE NewPattern*"); Console.Ln;
    WHILE i < LEN(data) DO data[i] := 0X; INC(i) END ;
	Console.String("***DBG*** X11.Mod *** while finished"); Console.Ln;
    (*QueryBestSize(display, class, primary, width, height, w, h);*)
    (*WHILE w < width DO w := w*2 END ;*)
    (*WHILE h < height DO h := h*2 END ;*)
    w := width; h := height;
    srcw := (width+31) DIV 32; (* number of words in source line *)
    destb := (w+7) DIV 8; (* number of bytes in dest line *)
    srci := (height-1)*srcw; desti := 0;
	Console.String("***DBG*** X11.Mod ***  WHILE srci >= 0 DO"); Console.Ln;
    WHILE srci >= 0 DO
      i := 0; j := 0; b := 0; dest := 0;
	  Console.String("***DBG*** X11.Mod *** LOOP"); Console.Ln;
      LOOP
        dest := dest DIV 2;
        IF b IN image[srci+j+1] THEN INC(dest, 80H) END;
        INC(b);
        IF b MOD 8 = 0 THEN
		  Console.String("***DBG*** X11.Mod *** b MOD 8 = 0"); Console.Ln;
          data[desti+i] := CHR(dest); INC(i); dest := 0;
          IF i >= destb THEN EXIT END
        END;
        IF b = 32 THEN b := 0; INC(j);
          IF j >= srcw THEN
            WHILE i < destb DO data[desti+i] := 0X; INC(i) END;
            EXIT
          END
        END
      END;
      INC(desti, destb); DEC(srci, srcw)
    END;
    Kernel.Lock();
	Console.String("***DBG*** X11.Mod *** pixmap := CreateBitmapFromData(display, "); Console.Ln;
    pixmap := CreateBitmapFromData(display, primary, S.ADR(data[0]), w, h);
    Kernel.Unlock();
    IF pixmap = 0 THEN 
	   Console.String("***DBG*** X11.Mod *** IF pixmap = 0 THEN HALT(99)..."); Console.Ln;
	   HALT(99) 
	END ;
    pat := S.VAL(PatternPtr, Kernel.malloc(SIZE(PatternDesc)));
    pat.x := 0; pat.y := 0; pat.w := width; pat.h := height; pat.pixmap := pixmap;
	Console.String("***DBG*** X11.Mod *** RETURN S.VAL(LONGINT, pat); END NewPattern"); Console.Ln;
    RETURN S.VAL(LONGINT, pat)
  END NewPattern;

  PROCEDURE RasterToPixmap*(base: LONGINT; width, height: INTEGER): LONGINT;
    VAR pixmap: Pixmap;
  BEGIN
    Console.String("***DBG*** X11.Mod *** PROCEDURE RasterToPixmap*"); Console.Ln;
    Kernel.Lock();
    pixmap := CreateBitmapFromData(display, primary, base, width, height);
    Kernel.Unlock();
    IF pixmap = 0 THEN 
	   Console.String("***DBG*** X11.Mod *** pixmap = 0, HALT(99)"); Console.Ln;
	   HALT(99) 
	END ;
	Console.String("***DBG*** X11.Mod *** RETURN pixmap"); Console.Ln;
    RETURN pixmap
  END RasterToPixmap;

  PROCEDURE SetColor*(col, red, green, blue: INTEGER);  (* 0 <= col, red, green, blue < 256 *)
    VAR xcol, cfore, cback: Color;
      error: ARRAY 15 OF CHAR;
  BEGIN
    Console.String("***DBG*** X11.Mod *** PROCEDURE SetColor*"); Console.Ln;
    Kernel.Lock();
    IF depth = 24 (* hack to support TrueColor displays *) THEN
       Console.String("***DBG*** X11.Mod *** depth = 24"); Console.Ln;
       pixelValues[col] := ASH(red, 0) + ASH(green, 8) + ASH(blue, 16) 
    END ;
    IF colorClass =  grayscale THEN 
	   Console.String("***DBG*** X11.Mod *** colorClass =  grayscale"); Console.Ln;
	   green := red; blue := red 
	END ;
    RGB[col+1].r := red; RGB[col+1].g := green; RGB[col+1].b := blue;
    IF (colorClass # monochrome) & (col >= 0) THEN
	  Console.String("***DBG*** X11.Mod *** (colorClass # monochrome) & (col >= 0)"); Console.Ln;
      (*xcol.red := 256*red; xcol.green := 256*green; xcol.blue := 256*blue;*)
      ulmTypes.ToInt16(256*red, xcol.red); ulmTypes.ToInt16(256*green, xcol.green); ulmTypes.ToInt16(256*blue, xcol.blue);
      xcol.flags := CHR(DoAll);
      xcol.pixel := pixelValues[col];
      IF col < nofcol THEN
	    Console.String("***DBG*** X11.Mod *** col < nofcol"); Console.Ln;
        StoreColor(display, cmap, S.ADR(xcol))
      ELSE (*error := "try option -c"; HALT(99)*)
      END ;
      IF ((col = BackgroundCol) OR (col = ForegroundCol)) & (arrow # 0) THEN
	    Console.String("***DBG*** X11.Mod *** ((col = BackgroundCol) OR (col = ForegroundCol)) & (arrow # 0)"); Console.Ln;
        (*cfore.red := 256*RGB[ForegroundCol+1].r;*)
        ulmTypes.ToInt16(256*RGB[ForegroundCol+1].r, cfore.red);
        (*cfore.green := 256*RGB[ForegroundCol+1].g;*)
        ulmTypes.ToInt16(256*RGB[ForegroundCol+1].g, cfore.green);
        (*cfore.blue := 256*RGB[ForegroundCol+1].b;*)
        ulmTypes.ToInt16(256*RGB[ForegroundCol+1].b, cfore.blue);
        (*cback.red := 256*RGB[BackgroundCol+1].r;*)
        ulmTypes.ToInt16(256*RGB[BackgroundCol+1].r, cback.red);
        (*cback.green := 256*RGB[BackgroundCol+1].g;*)
        ulmTypes.ToInt16(256*RGB[BackgroundCol+1].g, cback.green);
        (*cback.blue := 256*RGB[BackgroundCol+1].b;*)
        ulmTypes.ToInt16(256*RGB[BackgroundCol+1].b, cback.blue);
        RecolorCursor(display, arrow, S.ADR(cfore), S.ADR(cback))
      END
    END ;
    Kernel.Unlock();
	Console.String("***DBG*** X11.Mod ***  END SetColor;"); Console.Ln;
  END SetColor;

  PROCEDURE GetColor*(col: INTEGER; VAR red, green, blue: INTEGER);
  BEGIN 
     Console.String("***DBG*** X11.Mod *** PROCEDURE GetColor*"); Console.Ln;
	 red := RGB[col+1].r; green := RGB[col+1].g; blue := RGB[col+1].b;
     Console.String("***DBG*** X11.Mod ***  END GetColor;"); Console.Ln;
  END GetColor;

  PROCEDURE FlushLCache*;
    VAR gc: GC; window: Window;
  BEGIN
    Console.String("***DBG*** X11.Mod *** PROCEDURE FlushLCache*"); Console.Ln;
    Kernel.Lock();
    gc := Gc;
    IF lcmode = paint THEN lcmode := replace END ;
    (* DrawString modifies only foreground pixels, replace and paint modes work as Oberon paint mode *)
    IF lcmode # lastmode THEN 
	   Console.String("***DBG*** X11.Mod *** lcmode # lastmode, SetFunction(display..."); Console.Ln;
	   SetFunction(display, gc, function[lcmode]); lastmode := lcmode
	END ;
    IF lccol # lastcol THEN 
	   Console.String("***DBG*** X11.Mod *** lccol # lastcol,  SetForeground(display..."); Console.Ln;
	   SetForeground(display, gc, pixelValues[lccol]); lastcol := lccol
	END ;
    IF lcf # lastfont THEN 
	   Console.String("***DBG*** X11.Mod *** lcf # lastfont; SetFont(display"); Console.Ln;
	   SetFont(display, gc, SHORT(lcf.xid)); lastfont := lcf  
	END ;
    IF lcy0 >= 0 THEN window := primary ELSE window := secondary; DEC(lcy0, UBottom) END ;
	Console.String("***DBG*** X11.Mod *** DrawString(display, window, gc, l..."); Console.Ln;
    DrawString(display, window, gc, lcx0, Height-lcy0, S.ADR(lcache), lclen);
    lclen := 0;
    Kernel.Unlock();
	Console.String("***DBG*** X11.Mod *** END FlushLCache;"); Console.Ln;
  END FlushLCache;

  PROCEDURE DoSync*;
  BEGIN
    Console.String("***DBG*** X11.Mod *** PROCEDURE DoSync*;"); Console.Ln;
    IF lclen > 0 THEN 
	   Console.String("***DBG*** X11.Mod *** lclen > 0; FlushLCache..."); Console.Ln;
	   FlushLCache 
	END ;
    Kernel.Lock(); 
	Console.String("***DBG*** X11.Mod *** Sync(display, 0);"); Console.Ln;
	Sync(display, 0); 
	Kernel.Unlock();
	Console.String("***DBG*** X11.Mod ***  END DoSync;"); Console.Ln;
  END DoSync;

  PROCEDURE DoFlush*;
  BEGIN
    Console.String("***DBG*** X11.Mod ***  PROCEDURE DoFlush*;"); Console.Ln;
    IF lclen > 0 THEN 
	   Console.String("***DBG*** X11.Mod *** lclen > 0; FlushLCache"); Console.Ln;
	   FlushLCache 
	END ;
    Kernel.Lock(); 
	Console.String("***DBG*** X11.Mod *** Flush(display);"); Console.Ln;
	Flush(display); 
	Kernel.Unlock();
	Console.String("***DBG*** X11.Mod *** END DoFlush;"); Console.Ln;
  END DoFlush;

  PROCEDURE Rebind*(keyString: ARRAY OF CHAR; VAR modifierStrings: Modlist; nofmod: INTEGER;
                  to: ARRAY OF CHAR; nofchar: INTEGER);
    VAR modlist: ARRAY 8 OF LONGINT; i: LONGINT;
  BEGIN i := 0;
    Console.String("***DBG*** X11.Mod *** PROCEDURE Rebind*"); Console.Ln;
    WHILE i < nofmod DO 
	   Console.String("***DBG*** X11.Mod *** WHILE i < nofmod DO"); Console.Ln;
	   modlist[i] := StringToKeysym(S.ADR(modifierStrings[i])); INC(i) 
	END ;
	Console.String("***DBG*** X11.Mod *** RebindKeysym(display..."); Console.Ln;
    RebindKeysym(display, StringToKeysym(S.ADR(keyString)), S.ADR(modlist), nofmod, S.ADR(to), nofchar);
	Console.String("***DBG*** X11.Mod *** END Rebind;"); Console.Ln;
  END Rebind;

  PROCEDURE InitNames;
    VAR i, j: INTEGER;
  BEGIN
    Console.String("***DBG*** X11.Mod *** PROCEDURE InitNames;"); Console.Ln;
    WinName := WinNameStr;
    Args.Get(Args.Pos("-title") + 1, WinName);
    IconName := IconNameStr;
    Args.Get(Args.Pos("-title") + 1, IconName);
    Copyright := CopyrightStr;
    WinNameCopyright := WinNameStr;
    i := 0; WHILE WinNameCopyright[i] # 0X DO INC(i) END ;
    j := 0; REPEAT WinNameCopyright[i] := Copyright[j]; INC(i); INC(j) UNTIL Copyright[j-1] = 0X;
	Console.String("***DBG*** X11.Mod *** END InitNames;"); Console.Ln;
  END InitNames;

  PROCEDURE OpenDisp;
    VAR child: Window; flagmask, fd: LONGINT; event: Event;
      gRoot: LONGINT; gX, gY, gW, gH, gBW, gD: INTEGER;
      offset: LONGINT;
      defgeo: ARRAY 64 OF CHAR; i: INTEGER;
      displayArg, geometryArg: ARRAY 256 OF CHAR;
      coption: BOOLEAN;

    PROCEDURE Int(n: LONGINT);
      VAR j: INTEGER;
    BEGIN j := 64;
	  Console.String("***DBG*** X11.Mod *** PROCEDURE Int(n: LONGINT);"); Console.Ln;
      WHILE n > 0 DO DEC(j); defgeo[j] := CHR(n MOD 10 + 48); n := n DIV 10 END ;
      WHILE j < 64 DO defgeo[i] := defgeo[j]; INC(i); INC(j) END;
	  Console.String("***DBG*** X11.Mod *** END Int;"); Console.Ln;
    END Int;
      
  BEGIN
    Console.String("***DBG*** X11.Mod *** PROCEDURE OpenDisp;"); Console.Ln;
    displayArg := ""; geometryArg := "";
    Args.Get(Args.Pos("-d") + 1, displayArg);
    Args.Get(Args.Pos("-g") + 1, geometryArg);
	Console.String("***DBG*** X11.Mod *** display := OpenDisplay(displayArg);"); Console.Ln;
    display := OpenDisplay(displayArg);
    IF display = 0 THEN Console.String("Cannot open display"); Console.Ln; Kernel.Exit(1) END ;
	Console.String("***DBG*** X11.Mod *** S.GET(display+8, fd);"); Console.Ln;
    S.GET(display+8, fd);
    INCL(Kernel.readSet[0], fd);
    screen := DefaultScreen(display);
    screenw := DisplayWidth(display, screen);
    screenh := DisplayHeight(display, screen);
    screenhmm := DisplayHeightMM(display, screen);
    depth := SHORT(DefaultDepth(display, screen));
    visualptr := DefaultVisual(display, screen); defvisualptr := visualptr;
    cmap := DefaultColormap(display, screen); defcmap := cmap;
    cells := DisplayCells(display, screen);
    planes := DisplayPlanes(display, screen);
    IF ForegroundCol = BlackCol THEN
	  Console.String("***DBG*** X11.Mod *** ForegroundCol = BlackCol"); Console.Ln;
      foreground := BlackPixel(display, screen);
      background := WhitePixel(display, screen)
    ELSE
	  Console.String("***DBG*** X11.Mod *** ForegroundCol # BlackCol"); Console.Ln;
      foreground := WhitePixel(display, screen);
      background := BlackPixel(display, screen)
    END ;
    root := DefaultRootWindow(display);
    i := 0; Int(screenw - 2*4); defgeo[i] := "x"; INC(i);
    Int(screenh - 23 - 4); defgeo[i] := "+"; INC(i);
    Int(4); defgeo[i] := "+"; INC(i); Int(23); defgeo[i] := 0X;
	Console.String("***DBG*** X11.Mod *** flagmask := Geometry(display,..."); Console.Ln;
    flagmask := Geometry(display, screen, geometryArg, defgeo, 0, 1, 1, 0, 0, gX, gY, gW, gH);
	Console.String("***DBG*** X11.Mod ***  primary := CreateSimpleWindow(di..."); Console.Ln;
    primary := CreateSimpleWindow(display, root, gX, gY, gW, gH, 0, foreground, background);
	Console.String("***DBG*** X11.Mod *** StoreName(display, primary,..."); Console.Ln;
    StoreName(display, primary, S.ADR(WinNameCopyright));
	Console.String("***DBG*** X11.Mod *** SetIconName(display, primar..."); Console.Ln;
    SetIconName(display, primary, S.ADR(IconName));
	Console.String("***DBG*** X11.Mod *** SetCommand(display, prima..."); Console.Ln;
    SetCommand(display, primary, Args.argv, Args.argc);
	Console.String("***DBG*** X11.Mod *** SelectInput(display, prima..."); Console.Ln;
    SelectInput(display, primary, ExposureMask);
	Console.String("***DBG*** X11.Mod *** MapRaised(display, primary);"); Console.Ln;
    MapRaised(display, primary);
    REPEAT 
	   Console.String("***DBG*** X11.Mod *** NextEvent(display, S.ADR(event))"); Console.Ln;
	   NextEvent(display, S.ADR(event)) 
	UNTIL (event.type = Expose) & (event.window = primary);

    (* adjust to physical window size *)
	Console.String("***DBG*** X11.Mod *** GetGeometry(display, primar..."); Console.Ln;
    GetGeometry(display, primary, gRoot, gX, gY, gW, gH, gBW, gD);
    IF gW MOD 8 # 0 THEN
      DEC (gW, gW MOD 8);
	  Console.String("***DBG*** X11.Mod *** ResizeWindow (display..."); Console.Ln;
      ResizeWindow (display, primary, gW, gH);
    END;
    Width := SHORT(gW);
    Height := SHORT(gH);
    Bottom := 0;
    UBottom := -Height;

    (* pixmap cannot be larger than screen: *)
    IF gW > screenw THEN gW := SHORT(screenw) END ;
    IF gH > screenh THEN gH := SHORT(screenh) END ;
    (* very slow if wider than 1024: not on a SUN *)
(*    IF gW > 1024 THEN gW := 1024 END ;  *)
    Console.String("***DBG*** X11.Mod *** secondary := CreatePixmap(display, pr..."); Console.Ln;
    secondary := CreatePixmap(display, primary, gW, gH, depth);
	Console.String("***DBG*** X11.Mod *** END OpenDisp;"); Console.Ln;
  END OpenDisp;

  PROCEDURE CreateColors;
    VAR col: INTEGER;
      planeMasks: ARRAY 8 OF LONGINT;
      visualInfo: VisualInfo;
      vis: VisualPtr; coption: BOOLEAN;
  BEGIN
    Console.String("***DBG*** X11.Mod *** PROCEDURE CreateColors;"); Console.Ln;
    coption := Args.Pos("-c") < Args.argc;
    col := 0; WHILE col < 256 DO pixelValues[col] := col; INC(col) END ;
    IF ~coption & (depth <= 4) THEN colorClass := monochrome
    ELSIF MatchVisualInfo(display, screen, depth, PseudoColor, S.ADR(visualInfo)) = 1 THEN
      colorClass := color; visualptr := visualInfo.visual
    ELSIF MatchVisualInfo(display, screen, depth, GrayScale, S.ADR(visualInfo)) = 1 THEN
      colorClass := grayscale; visualptr := visualInfo.visual
    ELSE colorClass := monochrome
    END ;
    IF colorClass = monochrome THEN
      ColLeft := Width;
      nofcol := 2;
      basePixel := S.VAL(LONGINT, S.VAL(SET, foreground) * S.VAL(SET, background));
      planesMask := S.VAL(LONGINT, S.VAL(SET, foreground) / S.VAL(SET, background));
      colorClass := monochrome;
      pixelValues[BackgroundCol] := background;
      pixelValues[ForegroundCol] := foreground;
      col := 1;
      WHILE col <= 14  DO
        pixelValues[col] := foreground;
        INC(col)
      END
    ELSE
      ColLeft := 0;
      vis := S.VAL(VisualPtr, visualptr);
      IF coption THEN
        nofcol := vis.mapEntries;
        cmap := CreateColormap(display, primary, visualptr, AllocAll);
        SetWindowColormap(display, primary, cmap);
        basePixel := 0;
        planesMask := ASH(1, depth) - 1
      ELSE
        nofcol := 16;
        IF AllocColorCells(display, cmap, False, S.ADR(planeMasks), 4, S.ADR(basePixel), 1) = 0 THEN
          Console.String("Not enough color cells"); Console.Ln; 
          Console.String("Try option -c to allocate a private colormap");
          Console.Ln; Kernel.Exit(1)
        END ;
        col := 0;
        planesMask := 0;
        WHILE col < 4 DO
          planesMask := planesMask + planeMasks[col]; INC(col)
        END ;
        col := 0;
        WHILE col < 16 DO
          pixelValues[col] := basePixel + (col MOD 2) * planeMasks[0] + (col DIV 2 MOD 2) * planeMasks[1] +
            (col DIV 4 MOD 2) * planeMasks[2] + (col DIV 8 MOD 2) * planeMasks[3];
          INC(col)
        END
      END ;
      foreground := pixelValues[ForegroundCol];
      background := pixelValues[BackgroundCol];
      SetWindowBackground(display, primary, background);
      ClearWindow(display, primary)
    END;
	Console.String("***DBG*** X11.Mod *** END CreateColors;"); Console.Ln;
  END CreateColors;

  PROCEDURE CreateGc;
  BEGIN
    Console.String("***DBG*** X11.Mod *** PROCEDURE CreateGc;"); Console.Ln;
    function[replace] := GXcopy;
    function[paint] := GXor;  (* not used *)
    (* drawing in invert mode with BackgroundCol on BackgroundCol is a no-op: *)
    IF S.VAL(SET, background) * S.VAL(SET, planesMask) # {} THEN function[invert] := GXequiv
    ELSE function[invert] := GXxor
    END ;
    Gc := CreateGC(display, primary, 0, 0);
    IF Gc = 0 THEN Console.String("Cannot create X graphic context"); Console.Ln; Kernel.Exit(1) END ;
    SetPlaneMask(display, Gc, planesMask);
    SetGraphicsExposures(display, Gc, True);
    SetBackground(display, Gc, background);
    lastcol := -1;
    lastmode := -1;
    lastfont := NIL;
	Console.String("***DBG*** X11.Mod *** END CreateGc"); Console.Ln;
  END CreateGc;

  PROCEDURE InitColors*;  (* << V3 *)
    VAR col, colScale: INTEGER;
  BEGIN
     Console.String("***DBG*** X11.Mod ***  PROCEDURE InitColors*; "); Console.Ln;
    IF colorClass = grayscale THEN
      IF BlackCol < WhiteCol THEN
        col := BlackCol;
        WHILE col <= WhiteCol DO
          SetColor(col, 17*col, 0, 0); INC(col)
        END
      ELSE
        col := WhiteCol;
        WHILE col <= BlackCol DO
          SetColor(col, 255 - 17*col, 0, 0); INC(col)
        END
      END
    ELSE
      colScale := 1;
      SetColor(BlackCol, 0, 0, 0); (*black*)
      SetColor(WhiteCol, 255, 255, 255); (*white*)
      SetColor(1, 255 DIV colScale, 0 DIV colScale, 0 DIV colScale);
      SetColor( 2, 0 DIV colScale, 255 DIV colScale, 0 DIV colScale);
      SetColor(3, 0 DIV colScale,  0 DIV colScale,  255 DIV colScale);
      SetColor(4, 255 DIV colScale, 0 DIV colScale, 255 DIV colScale);
      SetColor(5,  255 DIV colScale, 255 DIV colScale,  0 DIV colScale);
      SetColor( 6, 0 DIV colScale,  255 DIV colScale,  255 DIV colScale);
      SetColor( 7, 170 DIV colScale, 0 DIV colScale, 0 DIV colScale);
      SetColor( 8, 0 DIV colScale, 153 DIV colScale, 0 DIV colScale);
      SetColor( 9, 0 DIV colScale,   0 DIV colScale, 153 DIV colScale);
      SetColor(10, 119 DIV colScale, 0 DIV colScale, 204 DIV colScale);
      SetColor(11, 187 DIV colScale, 136 DIV colScale, 0 DIV colScale);
      SetColor(12, 136 DIV colScale, 136 DIV colScale, 136 DIV colScale);
      SetColor(13, 170 DIV colScale, 170 DIV colScale, 170 DIV colScale);
      SetColor(14, 204 DIV colScale, 204 DIV colScale, 204 DIV colScale);
    END;
	Console.String("***DBG*** X11.Mod *** END InitColors;"); Console.Ln;
  END InitColors;
  
  PROCEDURE CreatePatterns;
    VAR image: ARRAY 17 OF SET; i: INTEGER;
  BEGIN
    Console.String("***DBG*** X11.Mod *** PROCEDURE CreatePatterns;"); Console.Ln;
    image[1] := {};
    image[2] := {13};
    image[3] := {12..14};
    image[4] := {11..13};
    image[5] := {10..12};
    image[6] := {9..11};
    image[7] := {8..10};
    image[8] := {1, 7..9};
    image[9] := {1, 2, 6..8};
    image[10] := {1..3, 5..7};
    image[11] := {1..6};
    image[12] := {1..5};
    image[13] := {1..6};
    image[14] := {1..7};
    image[15] := {1..8};
    image[16] := {};
    arrowSource := NewPattern(image, CursorShape, 16, 16);

    image[1] := {13};
    image[2] := {12..14};
    image[3] := {11..15};
    image[4] := {10..14};
    image[5] := {9..13};
    image[6] := {8..12};
    image[7] := {0..1, 7..11};
    image[8] := {0..2, 6..10};
    image[9] := {0..3, 5..9};
    image[10] := {0..8};
    image[11] := {0..7};
    image[12] := {0..6};
    image[13] := {0..7};
    image[14] := {0..8};
    image[15] := {0..9};
    image[16] := {0..9};
    arrowMask := NewPattern(image, CursorShape, 16, 16);

    i := 1; WHILE i < 17 DO image[i] := {}; INC(i) END ;
    noCursorSource := NewPattern(image, CursorShape, 16, 16);
    noCursorMask := NewPattern(image, CursorShape, 16, 16);
	Console.String("***DBG*** X11.Mod *** END CreatePatterns;"); Console.Ln;
  END CreatePatterns;

  PROCEDURE InitCursors;
    VAR cfore, cback: Color; csource, cmask: PatternPtr;
  BEGIN
    Console.String("***DBG*** X11.Mod ***  PROCEDURE InitCursors;"); Console.Ln;
    (*cfore.red := 256*RGB[ForegroundCol+1].r;*)
    ulmTypes.ToInt16(256*RGB[ForegroundCol+1].r, cfore.red);
    (*cfore.green := 256*RGB[ForegroundCol+1].g;*)
    ulmTypes.ToInt16(256*RGB[ForegroundCol+1].g, cfore.green);
    (*cfore.blue := 256*RGB[ForegroundCol+1].b;*)
    ulmTypes.ToInt16(256*RGB[ForegroundCol+1].b, cfore.blue);
    (*cback.red := 256*RGB[BackgroundCol+1].r;*)
    ulmTypes.ToInt16(256*RGB[BackgroundCol+1].r, cback.red);
    (*cback.green := 256*RGB[BackgroundCol+1].g;*)
    ulmTypes.ToInt16(256*RGB[BackgroundCol+1].g, cback.green);
    (*cback.blue := 256*RGB[BackgroundCol+1].b;*)
    ulmTypes.ToInt16(256*RGB[BackgroundCol+1].b, cback.blue);
    csource := S.VAL(PatternPtr, arrowSource);
    cmask := S.VAL(PatternPtr, arrowMask);
    arrow := CreatePixmapCursor(display, csource.pixmap, cmask.pixmap, S.ADR(cfore), S.ADR(cback), 1, 1);
    csource := S.VAL(PatternPtr, noCursorSource);
    cmask := S.VAL(PatternPtr, noCursorMask);
    noCursor := CreatePixmapCursor(display, csource.pixmap, cmask.pixmap, S.ADR(cfore), S.ADR(cback), 1, 1);
	Console.String("***DBG*** X11.Mod *** END InitCursors;"); Console.Ln;
  END InitCursors;

  PROCEDURE MyErrorHandler*(display: Display; err: ErrorEventPtr): LONGINT;
  BEGIN
    Console.String("***DBG*** X11.Mod *** PROCEDURE MyErrorHandler*(display: Display; err"); Console.Ln;
    ErrorFlag := TRUE;
    GetErrorText(display, ORD(err.errorCode), S.ADR(ErrorText), LEN(ErrorText));
	Console.String("***DBG*** X11.Mod *** RETURN 0; END MyErrorHandler;"); Console.Ln;
    RETURN 0
  END MyErrorHandler;

  PROCEDURE MyIOErrorHandler(display: Display): LONGINT;
  BEGIN 
     Console.String("***DBG*** X11.Mod *** PROCEDURE MyIOErrorHandler(display: Display): LONGINT;"); Console.Ln;
	 ErrorFlag := TRUE; 
	 Kernel.Exit(0)
  END MyIOErrorHandler;

BEGIN
  backgroundCol := BackgroundCol;
  foregroundCol := ForegroundCol;
  Console.String("***DBG*** X11.Mod *** InitNames;"); Console.Ln;
  InitNames;
  Console.String("***DBG*** X11.Mod *** OpenDisp;"); Console.Ln;
  OpenDisp;
  Console.String("***DBG*** X11.Mod *** CreateColors;"); Console.Ln;
  CreateColors;
  Console.String("***DBG*** X11.Mod *** CreateGc;"); Console.Ln;
  CreateGc;
  Console.String("***DBG*** X11.Mod *** InitColors;"); Console.Ln;
  InitColors;
  Console.String("***DBG*** X11.Mod *** CreatePatterns;"); Console.Ln;
  CreatePatterns;
  Console.String("***DBG*** X11.Mod *** InitCursors;"); Console.Ln;
  InitCursors;
  Console.String("***DBG*** X11.Mod *** DefineCursor(display, primary, arrow);"); Console.Ln;
  DefineCursor(display, primary, arrow);
  lclen := 0;
  ErrorFlag := FALSE;
  (* SetErrorHandler(MyErrorHandler); *)
  Console.String("***DBG*** X11.Mod *** SetIOErrorHandler(MyIOErrorHandler)"); Console.Ln;
  SetIOErrorHandler(MyIOErrorHandler)
END X11.
